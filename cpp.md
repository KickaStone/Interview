# CPP

## 语言特性

面向对象OOP

## 语言：语言特性
面向对象OOP
1. 封装：属性、方法封装在类中
2. 继承：子类继承父类，实现代码重用和拓展
3. 多态：不同类以统一接口进行交互。
1. 编译时多态：函数重载和运算符重载
2. 运行时多态：基类指针，虚函数
```c++
class Base {
public:
	virtual void show()
	{
		std::cout << "Base class show function" << std::endl;
	}
};
class Derived : public Base {
public:
	void show() override
	{
		std::cout << "Derived class show function" << std::endl;
	}
};
int main()
{
	Base *ptr;
	Derived obj;
	ptr = &obj;
	ptr->show(); /* 输出：Derived class show function */
}
```
### C++11
**类型推导`auto & decltype`**
在编译器推导出变量或表达式的类型。
`auto a = 10;`
```c++
const int i = 1;
int a = 2;
decltype(i) b = 2; // b是const int&
```
**左值右值**
相关概念：
左值：可以取地址并且有名字
右值：不可以取地址没有名字
纯右值：运算表达式产生的临时变量
将亡值：将要销毁的值
左值引用：对左值进行引用的类型
右值引用：右值的引用，可以用在函数参数中捕获右值，用于实现移动语义和完美转发
移动语义：转移资源所有权，类似与转让或者资源窃取的意思
完美转发：函数模板，转发到其他函数，目标函数收到与转发函数完全相同的实参
```c++
template<typename T>
void wrapper(T&& a){
    process(std::forward<T>(a));
}
void process(int& x){
    std::cout << x << std::endl;
}
void process(int&& x){
    std::cout << x << std::endl;
}
```
返回值优化：避免创建临时对象和调用拷贝构造函数
**智能指针**
* `shared_ptr` 多个可以指向一个对象，使用引用计数（引用计数的增减是线程安全的），引用为**0**自动释放内存；可能导致循环引用的问题（两个对象互相持有对方的`shared_ptr`）。
* `weak_ptr` 弱引用，不增加引用计数，观察对象，防止循环引用。
* `unique_ptr` 独占类型的指针，不允许其他智能指针共享其内部指针，不允许`unique_ptr`拷贝和赋值。****
## STL 容器
| 容器               | 底层数据结构      | 时间复杂度                                                    | 有无序 | 可不可重复 | 其他                                                                         |
| ------------------ | ----------------- | ------------------------------------------------------------- | ------ | ---------- | ---------------------------------------------------------------------------- |
| array              | 数组              | 随机读改 O(1)                                                 | 无序   | 可重复     | 支持随机访问                                                                 |
| vector             | 数组              | 随机读改、尾部插入、尾部删除 O(1) <br>头部插入、头部删除 O(n) | 无序   | 可重复     | 支持随机访问                                                                 |
| deque              | 双端队列          | 头尾插入、头尾删除 O(1)                                       | 无序   | 可重复     | 一个中央控制器 + 多个缓冲区，支持首尾快速增删，支持随机访问                  |
| forward_list       | 单向链表          | 插入、删除 O(1)                                               | 无序   | 可重复     | 不支持随机访问                                                               |
| list               | 双向链表          | 插入、删除 O(1)                                               | 无序   | 可重复     | 不支持随机访问                                                               |
| stack              | deque / list      | 顶部插入、顶部删除 O(1)                                       | 无序   | 可重复     | deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时 |
| queue              | deque / list      | 尾部插入、头部删除 O(1)                                       | 无序   | 可重复     | deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时 |
| priority_queue     | vector + max-heap | 插入、删除 O(log2n)                                           | 有序   | 可重复     | vector容器+heap处理规则                                                      |
| set                | 红黑树            | 插入、删除、查找 O(log2n)                                     | 有序   | 不可重复   |                                                                              |
| multiset           | 红黑树            | 插入、删除、查找 O(log2n)                                     | 有序   | 可重复     |                                                                              |
| map                | 红黑树            | 插入、删除、查找 O(log2n)                                     | 有序   | 不可重复   |                                                                              |
| multimap           | 红黑树            | 插入、删除、查找 O(log2n)                                     | 有序   | 可重复     |                                                                              |
| unordered_set      | 哈希表            | 插入、删除、查找 O(1) 最差 O(n)                               | 无序   | 不可重复   |                                                                              |
| unordered_multiset | 哈希表            | 插入、删除、查找 O(1) 最差 O(n)                               | 无序   | 可重复     |                                                                              |
| unordered_map      | 哈希表            | 插入、删除、查找 O(1) 最差 O(n)                               | 无序   | 不可重复   |                                                                              |
| unordered_multimap | 哈希表            | 插入、删除、查找 O(1) 最差 O(n)                               | 无序   | 可重复     |                                                                              |
## 关键字/保留字
1. const
   1. 常量 `const int val = 1000;`，其值不能改变
   2. 常量指针
   3. 指向常量的指针 `cosnt int* ptr = &a` 指针本身是常量，不能改变指向的地址，但可以通过指针修改指向的值
   4. 常量指针 `int * const ptr = &a` ，不能修改指针和指向的值
   5. 常量成员函数，表示改成员函数不会修改对象状态 `int f () const {...}`
   6. 常量参数 `void f(const int& a)` 防止函数修改传入的参数
2. extern
extern声明变量或函数为外部链接，该变量或函数名在其他文件中可见，静态分配空间。
3. volitale
关键字用来修饰变量，表示该变量的值可能会在程序的控制流之外发生改变。
限制编译器进行某些优化行为。
4. new
`new`用于申请内存并返回所申请内存的指针，可用于分配基本数据类型、对象或数组。`new`的时候会自动调用构造函数。`new`返回的指针类型是已知的，比`malloc`更安全，避免类型转换错误。必须通过`delete`释放new过的内存。对比malloc如下

    | 特性             | c++ new           | c malloc                     |
    | ---------------- | ----------------- | ---------------------------- |
    | 自动调用构造函数 | 是                | 否                           |
    | 返回类型         | 所需类型的指针    | `void*`需要显示类型转换      |
    | 内存初始化       | 自动初始化        | 不初始化，内存内容是未定义的 |
    | 释放内存         | `delete/delete[]` | `free`                       |
5. void
表示无类型，通常用于返回类型或指针类型
   1. 函数返回类型，`void f()`表示函数无返回值
   2. 指向无类型的指针，表示该指针不指向特定的数据，是中立指针，必须显示转换为其他类型才能使用
   3. 用在函数参数，表示函数不接受任何参数
   4. 与模板和函数重载结合使用
   5. static
   6. 在函数内部使用，该变量的生命周期会延续到程序结束，而不是每次调用函数时重新创建
   7. 在类中使用，修饰成员变量时（静态成员变量），所有类对象共享同一个静态成员变量；修饰成员函数时（静态成员函数），该成员函数只能访问静态成员变量和静态成员函数，并且不用创建对象就能直接调用。
   8. 在文件作用域中使用：限制为内部使用，其他文件无法访问这些变量或函数。
6. default
    用于类中，使用`void f() = default`，可以让继承的类生成对应的默认函数，比如构造函数、析构函数和成员函数